using System.Text.RegularExpressions; namespace Dialogus.Core; public static class DialogueParser{ public static DialogueDocument Parse(string source){ var doc=new DialogueDocument(); DialogueNode? current=null; var lines=source.Replace("\r\n","\n").Replace('\r','\n').Split('\n'); var stack=new Stack<(Condition cond,List<IDialogueInstruction> then)>(); foreach(var raw in lines){ var line=raw.Trim(); if(line.Length==0||line.StartsWith("//")) continue; if(line.StartsWith("::")){ if(stack.Count>0) throw new Exception("if/endif pendente"); var name=line[2..].Trim(); current=new DialogueNode{ Name=name }; doc.Nodes[name]=current; continue;} if(current is null) throw new Exception("Instrução fora de nó: "+line); if(line.StartsWith("if ")){ var cond=ParseCondition(line[3..].Trim()); stack.Push((cond,new())); continue;} if(line=="endif"){ if(stack.Count==0) throw new Exception("endif sem if"); var (cond,then)=stack.Pop(); Add(current,new If(cond,then),stack); continue;} if(line.StartsWith("set ")){ var rem=line[4..].Trim(); var idx=rem.IndexOf('='); if(idx<0) throw new Exception("set inválido"); var name=rem[..idx].Trim(); var lit=ParseValue(rem[(idx+1)..].Trim()); Add(current,new SetVar(name,lit),stack); continue;} if(line.StartsWith("goto ")){ Add(current,new Goto(line[5..].Trim()),stack); continue;} if(line.StartsWith("?")){ var m=Regex.Match(line,"^\\?\\s*\"(.*)\"\\s*->\\s*([a-zA-Z0-9_\\-]+)$"); if(!m.Success) throw new Exception("Opção inválida: "+line); var text=m.Groups[1].Value; var target=m.Groups[2].Value; var last=Peek(current,stack); if(last is ChoiceList cl) cl.Options.Add(new Choice(text,target)); else Add(current,new ChoiceList(new(){ new(text,target)}),stack); continue;} if(line.StartsWith("\"")&&line.EndsWith("\"")&&line.Length>=2){ Add(current,new Say(line[1..^1]),stack); continue;} throw new Exception("Linha não reconhecida: "+line);} if(stack.Count>0) throw new Exception("Arquivo terminou com if/endif pendente."); return doc;} static void Add(DialogueNode node,IDialogueInstruction instr, Stack<(Condition cond,List<IDialogueInstruction> then)> stack){ if(stack.Count==0) node.Instructions.Add(instr); else stack.Peek().then.Add(instr);} static IDialogueInstruction? Peek(DialogueNode node, Stack<(Condition cond,List<IDialogueInstruction> then)> stack){ var list=stack.Count==0? node.Instructions: stack.Peek().then; return list.Count>0? list[^1]: null;} static Condition ParseCondition(string expr){ var mEq=Regex.Match(expr,"^([a-zA-Z_][a-zA-Z0-9_]*)\\s*==\\s*(.+)$"); if(mEq.Success) return new Condition.Eq(mEq.Groups[1].Value, ParseValue(mEq.Groups[2].Value)); var mNe=Regex.Match(expr,"^([a-zA-Z_][a-zA-Z0-9_]*)\\s*!=\\s*(.+)$"); if(mNe.Success) return new Condition.Neq(mNe.Groups[1].Value, ParseValue(mNe.Groups[2].Value)); var mVar=Regex.Match(expr,"^([a-zA-Z_][a-zA-Z0-9_]*)$"); if(mVar.Success) return new Condition.Var(mVar.Groups[1].Value); throw new Exception("Expressão inválida: "+expr);} static Value ParseValue(string s){ s=s.Trim(); if(s.Equals("true",StringComparison.OrdinalIgnoreCase)) return new Value.Bool(true); if(s.Equals("false",StringComparison.OrdinalIgnoreCase)) return new Value.Bool(false); if(int.TryParse(s,out var n)) return new Value.Num(n); var m=Regex.Match(s,"^\"(.*)\"$"); if(m.Success) return new Value.Str(m.Groups[1].Value); return new Value.Str(s);} }